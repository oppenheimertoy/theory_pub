# Операционные системы - Теория

В данном разделе будет описана теория, которая читается в курсе ОС от Алега Юрыча Еремина. К счастью для нас, Еремин, во многом опирается на плечи мистера Таненбаума, чем облегчает поиск теории.

Структура файла будет такой же, как и структура слайдов лекций. Там много вопросов, на которые будем отвечать. Иногда с отступлениями. Плюс дополнять конспектами с лекций если АЮ будет отступать от темы слайдов. А он будет...   

# Лекция 1. Классификация, основные понятия и характеристики операционных систем

## Жизненный цикл программы
> ***Вспоминаем этапы ЖЦ программы***

Программный жизненный цикл относится к различным этапам, через которые проходит программное обеспечение, начиная от первоначального замысла и заканчивая его окончательным выводом из эксплуатации. Этот цикл обычно делится на несколько отдельных фаз, каждая из которых имеет свой набор действий и целей. Ниже приведены типичные этапы жизненного цикла программы, вместе с примерами и подробными объяснениями:

- **Планирование и aнализ**

    Выявление необходимости в новой программе или обновлении существующей.
    Определение целей и объема программы.
    Проведение исследований жизнеспособности.
    Создание плана проекта.
    Пример:
    Компания осознает необходимость в новой системе управления запасами для повышения эффективности. Они проводят исследование рынка, определяют требования к системе и создают план проекта.

-  **Проектирование**

    Проектирование архитектуры программы.
    Создание подробных дизайн-документов.
    Проектирование пользовательского интерфейса.
    Определение системных интеграций и потока данных.
    Пример:
    Команда проектирует систему управления запасами, указывая, как будет выглядеть пользовательский интерфейс, как будут храниться данные и как система будет взаимодействовать с другими существующими системами.

- **Реализация (Кодирование)**

    Написание фактического кода для программы.
    Соблюдение стандартов и практик кодирования.
    Проведение модульного тестирования.
    Пример:
    Разработчики пишут код для системы управления запасами, обеспечивая работу каждого модуля как предполагалось. Они проводят модульные тесты для проверки отдельных компонентов.

- **Тестирование**

    Проведение различных типов тестирования (например, интеграционное тестирование, системное тестирование, тестирование на приемлемость пользователем).
    Выявление и исправление ошибок.
    Обеспечение соответствия программы требованиям.
    Пример:
    Система тестируется в целом, чтобы убедиться, что все части работают вместе. Сотрудники используют систему в контролируемой среде, чтобы убедиться, что она соответствует их потребностям.

- **Внедрение**

    Развертывание программы в производственной среде.
    Предоставление обучения пользователям.
    Мониторинг первоначального развертывания на предмет проблем.
    Пример:
    Система управления запасами внедряется во всей компании. Персонал обучается, как ей пользоваться, и ИТ-команда отслеживает систему на предмет каких-либо немедленных проблем.

- **Обслуживание и поддержка**

    Предоставление постоянной поддержки и устранение неполадок.
    Выпуск обновлений и патчей.
    Документирование и исправление ошибок.
    Пример:
    Компания продолжает поддерживать систему управления запасами, выпуская обновления для добавления новых функций или исправления ошибок по мере необходимости.

- **Вывод из эксплуатации и замена**

    Принятие решения о выводе программы из эксплуатации.
    Миграция данных и процессов в новую систему.
    Демонтаж старой системы.
    Пример:
    Спустя годы, по мере развития технологий, компания решает заменить систему управления запасами на более современное решение. Они мигрируют данные в новую систему и поэтапно выводят из эксплуатации старую.

> ***Входные и выходные данные***

- **Входные данные**:
    Входные данные - это данные или информация, которая предоставляется программе для выполнения задачи или процесса. Эти данные могут поступать из различных источников, таких как ввод пользователя, файлы, датчики или другие программы. Программа обрабатывает эти входные данные в соответствии с разработанной логикой для получения желаемого результата.

- **Выходные данные**:

    Выходные данные - это результат, произведенный программой после обработки входных данных. Этот результат может принимать различные формы, такие как отображаемая информация на экране, сохраненные файлы, сигналы другим устройствам или данные, отправленные по сети. Выходные данные обычно являются конечной целью работы программы и используются для принятия решений, дальнейшей обработки или как готовый продукт.

> ***Вычислительный процесс***

Ключевым понятием во всех операционных системах является процесс. Процессом, по
существу, является программа во время ее выполнения. С каждым процессом связано его
адресное пространство — список адресов ячеек памяти от нуля до некоторого максиму-
ма, откуда процесс может считывать данные и куда может записывать их. Адресное про-
странство содержит выполняемую программу, данные этой программы и ее стек. Кроме
этого, с каждым процессом связан набор ресурсов, который обычно включает регистры
(в том числе счетчик команд и указатель стека), список открытых файлов, необрабо-
танные предупреждения, список связанных процессов и всю остальную информацию,
необходимую в процессе работы программы. Таким образом, процесс — это контейнер,
в котором содержится вся информация, необходимая для работы программы.

При всем многообразии алгоритмов решения задач в них можно выделить три основных вида вычислительных процессов:

- линейный
- ветвящийся
- циклический

*Линейным* - называется такой вычислительный процесс, при котором все этапы решения задачи выполняются в естественном порядке следования записи этих этапов.

*Ветвящимся* - называется такой вычислительный процесс, в котором выбор направления обработки информации зависит от исходных или промежуточных данных (от результатов проверки выполнения какого-либо логического условия).

*Циклом* - называется многократно повторяемый участок вычислений. Вычислительный процесс, содержащий один или несколько циклов, называется циклическим.

По количеству выполнения циклы делятся на:

- циклы с определенным (заранее заданным) числом повторений
- циклы с неопределенным числом повторений.

Количество повторений последних зависит от соблюдения некоторого условия, задающего необходимость выполнения цикла. При этом условие может проверяться в начале цикла — тогда речь идет о цикле с предусловием, или в конце — тогда это цикл с постусловием.

> ***Дайте определение операционной системы?***

Дать точное определение операционной системы довольно трудно. Можно сказать, что
это программное обеспечение, которое работает в режиме ядра, но и это утверждение
не всегда будет соответствовать истинному положению вещей. Отчасти проблема здесь
в том, что операционные системы осуществляют две значительно отличающиеся друг от
друга функции: предоставляют прикладным программистам (и прикладным программам,
естественно) вполне понятный абстрактный набор ресурсов взамен неупорядоченного
набора аппаратного обеспечения и управляют этими ресурсами. В зависимости от того,
кто именно ведет разговор, можно услышать больше о первой или о второй из них.
Нам же предстоит рассмотреть обе эти функции.

> ***Всегда ли нужна операционная система?***

Если честно, не понял вопроса. Но, предполагаю, что ответ нет. Хотя опять же, все зависит от смысла вопроса... 0 Захаровых из 10.

**Краткий ответ:**
Нет, операционная система не всегда необходима. Определенные вычислительные задачи и системы могут функционировать без традиционной ОС. Однако для большинства общих вычислительных потребностей, особенно в личных компьютерах, смартфонах и серверах, ОС является необходимой.

**Подробное объяснение:**

- Программирование на голом металле (Bare-Metal Programming):

    При программировании на голом металле, программное обеспечение работает непосредственно на аппаратном обеспечении без ОС. Это распространено во встроенных системах, таких как микроконтроллеры в бытовых приборах, автомобильных системах или других специализированных устройствах.
    Эти системы часто выполняют одну определенную функцию, и их простота позволяет им работать без необходимости в ОС.

- Реально-временные операционные системы (RTOS):

    Некоторые системы используют RTOS, которые являются упрощенными операционными системами, предназначенными для приложений реального времени. Хотя технически это ОС, они намного проще и более специализированы, чем универсальные операционные системы, такие как Windows или Linux.
    Общее назначение вычислений:

**Вывод:**
Хотя технически возможно использовать компьютер без традиционной операционной системы, для большинства практических целей, особенно в потребительских и бизнес-вычислениях, операционная система является необходимой. Она упрощает взаимодействия, повышает безопасность и позволяет выполнять более сложные и разнообразные задачи. В специализированных областях, таких как встроенные системы или определенные задачи высокопроизводительных вычислений, работа без традиционной ОС более распространена.

## Этапы развития ЭВМ

Еремин на слайдах выделяет лишь 5 поклений. Таненбаум берет еще и нулевое поколение. На всякий случай распишу с нулевым поколением. Причем в первом РК в прошлом году **были вопросы на эту тему**, так что главные отличия поколений нужно понимать.

### С точки зрения вычислительного процесса

- ***"Нулевое поколение" - механические компьютеры
(1642–1945)***
    Первую счетную машину создал французский ученый Блез Паскаль в 1642 году, которая могла выполнять только сложение и вычитание. Через тридцать лет Готфрид Вильгельм фон Лейбниц усовершенствовал эту концепцию, создав машину, способную на умножение и деление. В 19 веке Чарльз Бэббидж, вдохновленный работами Паскаля и Лейбница, изобрел Разностную машину и позже Аналитическую машину, которая могла выполнять несколько алгоритмов и считается предшественником современных компьютеров. Ада Лавлейс, работавшая с Бэббиджем, признана первым программистом.

    Работа Конрада Зуса в Германии по созданию автоматических счетных машин на основе электромагнитных реле была пионерской, но не оказала значительного влияния на будущее компьютерной техники. В США значительный вклад внесли Джон Атанасов и Джордж Стиббиц. Машина Атанасова, хотя и не была введена в эксплуатацию, использовала двоичную арифметику и память на базе конденсаторов, похожую на современную ОЗУ. Машина Стиббица была более примитивной, но функциональной, продемонстрированной в 1940 году.

    Говард Айкен, повлиянный работами Бэббиджа, создал "Mark I" в 1944 году в Гарварде, что стало значительным шагом в области вычислительной техники, хотя вскоре устарело с началом эры электроники. Все эти новшества заложили основу для компьютеров, которыми мы пользуемся сегодня.

- ***Первое поколение - электронные лампы (1945–1955)***

    Тут можно рассказать про то, что во время войны произошел резкий буст из-за потребностей армии и тд. Но в основном нам тут интересно про фон Неймановскую архитектуру.
    Фон Нейман понял, что программирование компьютеров с большим количеством переключателей и кабелей было неэффективным и предложил хранить программу в памяти компьютера в цифровой форме вместе с данными. Он также заменил десятичную арифметику, используемую в ENIAC, на двоичную, аналогично тому, как ранее сделал Атанасов. Фон Нейман описал архитектуру, известную сейчас как фон-неймановская архитектура, которая стала основой большинства современных компьютеров.

    ![Архитектура фон Неймана](https://upload.wikimedia.org/wikipedia/commons/3/3c/%D0%90%D1%80%D1%85%D0%B8%D1%82%D0%B5%D0%BA%D1%82%D1%83%D1%80%D0%B0_%D1%84%D0%BE%D0%BD_%D0%9D%D0%B5%D0%B9%D0%BC%D0%B0%D0%BD%D0%B0.png) 

    Машина фон Неймана включала память на 4096 слов по 40 бит, арифметико-логическое устройство, устройство управления и устройства ввода-вывода. Внутри арифметико-логического устройства находился аккумулятор на 40 бит.

    Одновременно с работой над машиной IAS фон Неймана исследователи МТИ разрабатывали компьютер Whirlwind I, предназначенный для работы в реальном времени с словами по 16 бит. Этот проект привел к изобретению памяти на магнитном сердечнике и первого серийного мини-компьютера. IBM, изначально производившая перфокарты и механические машины для их сортировки, построила свой первый компьютер 701 только в 1953 году, значительно позже, чем компания Экерта и Моушли с компьютером UNIVAC. Компьютер 701 содержал 2048 слов по 36 бит, а через три года был выпущен компьютер 704 с улучшенными характеристиками и процессором для вычислений с плавающей точкой. В 1958 году IBM начала работу над компьютером 709 на электронных лампах, представлявшим собой усовершенствованную версию 704.

> *Я так подумал, что изложение в Таннебауме слишком подробное и бесполезное. Ниже тогда просто закину тезисно различие по поколениям, чтобы информацией не перегружать*

### Компьютеры первого поколения (1940-е - 1950-е годы):
1. **Технология**: Использование электронных ламп в качестве основного электронного компонента.
2. **Размер**: Очень большие, часто занимали целые комнаты.
3. **Скорость и эффективность**: Относительно медленные и менее эффективные из-за ограничений технологии электронных ламп.
4. **Генерация тепла**: Выделяли много тепла, что требовало сложных систем охлаждения.
5. **Программирование**: В основном программирование на машинном языке.
6. **Хранение**: Ограниченные возможности хранения, часто использовались магнитные барабаны или линии задержки.
7. **Примеры**: ENIAC, UNIVAC, IBM 701.

### Компьютеры второго поколения (1950-е - 1960-е годы):
1. **Технология**: Введение транзисторов, заменяющих электронные лампы. Транзисторы были меньше, быстрее, надежнее и более энергоэффективны.
2. **Размер**: Меньше, чем компьютеры первого поколения, но все еще значительные по современным меркам.
3. **Скорость и эффективность**: Значительно быстрее и эффективнее благодаря технологии транзисторов.
4. **Генерация тепла**: Выделяли меньше тепла по сравнению с электронными лампами, что облегчало требования к охлаждению.
5. **Программирование**: Введение высокоуровневых языков программирования, таких как FORTRAN и COBOL, что сделало программирование более доступным.
6. **Хранение**: Улучшенные возможности хранения с введением магнитной ядерной памяти.
7. **Примеры**: IBM 7090, PDP-1, UNIVAC II.

### Компьютеры третьего поколения (1960-е - 1970-е годы):
1. **Технология**: Использование интегральных схем (ИС), которые собрали множество транзисторов на одном кремниевом чипе.
2. **Размер**: Еще меньше, благодаря миниатюризации компонентов.
3. **Скорость и эффективность**: Значительно увеличилась скорость и эффективность, сократились времена отклика.
4. **Энергопотребление**: Уменьшилось энергопотребление и выделение тепла.
5. **Программирование**: Расширение использования высокоуровневых языков, появление операционных систем.
6. **Хранение**: Большие объемы памяти и улучшенные носители данных.
7. **Примеры**: IBM System/360, PDP-8.

### Компьютеры четвертого поколения (1970-е - 1990-е годы):
1. **Технология**: Введение микропроцессоров, объединяющих центральный процессор на одном кремниевом чипе.
2. **Размер**: Настольные и портативные компьютеры стали возможны благодаря дальнейшей миниатюризации.
3. **Скорость и эффективность**: Огромный рост производительности, увеличение скорости обработки данных.
4. **Персональные компьютеры**: Распространение персональных компьютеров (ПК).
5. **Программирование**: Развитие графических пользовательских интерфейсов и многозадачности.
6. **Интернет**: Распространение Интернета и развитие сетевых технологий.
7. **Примеры**: Apple Macintosh, IBM PC.

### Компьютеры пятого поколения (1990-е - настоящее время):
1. **Технология**: Использование искусственного интеллекта, распараллеливание процессов, нанотехнологии.
2. **Размер**: Дальнейшее уменьшение размеров, появление мобильных устройств.
3. **Скорость и эффективность**: Высокая производительность, быстрая обработка больших объемов данных.
4. **Сетевые технологии**: Широкополосный доступ в Интернет, облачные вычисления.
5. **Программирование**: Распространение объектно-ориентированного программирования и мобильных приложений.
6. **Искусственный интеллект**: Развитие технологий ИИ и машинного обучения.
7. **Примеры**: Смартфоны, планшеты, современные ПК.

> Вопрос из РК: Какие особенности появились у ЭВМ при переходе с ламповых на полупроводниковые транзисторы, как это повлияло на операционные системы

Ну соотв пишем, что с точки зрения ОС повысился функционал, увеличился фактор многозадачности и в целом появилась возможность поддерживать более сложные программы.

> Какие бывают операционные системы?

### Основанные на типе устройства:

1. **Операционные системы для настольных компьютеров**: Разработаны для личных компьютеров. Примеры включают Windows, macOS и дистрибутивы Linux, такие как Ubuntu.
2. **Серверные операционные системы**: Разработаны для управления серверами. Примеры включают Windows Server, серверные дистрибутивы Linux, такие как CentOS, и системы на базе UNIX, такие как Solaris.
3. **Мобильные операционные системы**: Для смартфонов и планшетов. Примеры включают iOS, Android и HarmonyOS.
4. **Встроенные операционные системы**: Используются во встроенных системах, таких как маршрутизаторы, смарт-телевизоры и устройства IoT. Примеры включают Embedded Linux, VxWorks и FreeRTOS.

### Основанные на пользовательском интерфейсе:

1. **Операционные системы с графическим интерфейсом пользователя (GUI)**: Имеют графические интерфейсы, например, Windows, macOS и большинство современных дистрибутивов Linux.
2. **Операционные системы с интерфейсом командной строки (CLI)**: Управляются в основном через текстовые команды. Примеры включают некоторые системы UNIX и специализированные дистрибутивы Linux.

### Основанные на использовании и функциональности:

1. **Универсальные операционные системы**: Разработаны для широкого круга задач и пользователей, например, Windows, macOS и Linux.
2. **Операционные системы реального времени (RTOS)**: Разработаны для приложений реального времени, где критичны временные ограничения. Примеры включают QNX и VxWorks.
3. **Сетевые операционные системы**: Разработаны для управления сетевыми ресурсами. Примеры включают Novell NetWare и Microsoft Windows Server.
4. **Распределенные операционные системы**: Управляют коллекцией независимых компьютеров и создают видимость единого компьютера. Примеры включают Amoeba и Plan 9.

### Основанные на распространении и исходном коде:

1. **Проприетарные операционные системы**: Исходный код не доступен общественности. Примеры включают Windows и macOS.
2. **Операционные системы с открытым исходным кодом**: Исходный код доступен бесплатно и может быть изменен. Примеры включают Linux и FreeBSD.
3. **Операционные системы типа Freeware**: Бесплатны для использования, но не обязательно открыты. Некоторые дистрибутивы Linux подходят под это описание.

### Основанные на архитектуре:

1. **Монолитные операционные системы**: Имеют большое ядро, предоставляющее множество услуг. Примеры включают традиционные системы UNIX и ранние версии Linux.
2. **Операционные системы с микроядром**: Имеют небольшое ядро, с большинством служб, работающих как отдельные процессы. Примеры включают Minix и QNX.
3. **Гибридные операционные системы**: Сочетают элементы монолитной и микроядерной архитектур. Примеры включают современные Windows NT и Apple's XNU (используемые в macOS и iOS).

>*Тут я вообще все что можно перечислить добавил. В целом, нас интересует только разделение ОС по использованию и функциональности. Плюс Еремин добавил разделение на ОС общего и специального назначения*

### Основанные на назначении:
- общего назначения
- специального назначения
    - ОС на спутнике без графического дизайна
    - Криптопроцессор в банкомате, графическая карта не нужна
    - На телефоне нужна многозадачность
    - на квадрокоптерах система реального времени 


## Основные принципы построения ОС
Тут на слайдах перечислены принципы построения ОС. Нормального описания в литературе я не нашел, поэтому за этот раздел не ручаюсь. Опишем каждый из них:

### Частотный принцип
Частотный принцип реализации системных программ основан на выделении в
алгоритмах и в обрабатываемых массивах ОС действий и данных по частоте их
использования. Следствием применения частотного принципа в современных ОС - наличие
многоуровневого планирования при организации работы ОС.

### Принцип модульности
Принцип модульности отражает технологические и эксплуатационные свойства
системы, предусматривая оформление функционально законченных компонентов ОС в
виде отдельных модулей

### Принцип функциональной избирательности

Принцип функциональной избирательности предусматривает выделение некоторого
множества важных модулей, которые должны быть постоянно в "горячем" режиме для
обеспечения эффективного управления вычислительным процессом. Этот выделенный
набор модулей называют ядром ОС. При формировании состава ядра ОС ищут компромисс
между двумя разноречивыми требованиями: в состав ядра должны войти наиболее часто
используемые модули; объем памяти, занимаемый ядром ОС, должен быть как можно
меньше. Программы ядра ОС постоянно находятся в оперативной памяти ЭВМ и
называются резидентными. Программы ОС, подгружаемы в ОЗУ по мере необходимости
из внешней памяти, называются транзитными.

### Принцип генерируемости

Принцип генерируемости определяет такой способ исходного представления
системной программы ОС, который позволяет настраивать эту системную программу,
исходя из конкретной конфигурации аппаратных средств и круга решаемых проблем.

### Принцип функциональной избыточности

Принцип функциональной избыточности предусматривает обеспечение
возможности выполнения одной и той же работы различными средствами.

### Принцип по умолчанию

> *из конспектов челов*

- Переносим файл (папку) - копируется файл (папка)
- все одинаково

ну как бы ясно все, понятно там, все дела

### Принцип перемещаемости
Принцип перемещаемости предусматривает такое построение модулей ОС, при
котором результаты работы не зависят от места их расположения.

### Принцип защиты
Принцип защиты информации определяет необходимость разработки мер,
ограждающих программы и данные пользователя от искажений или нежелательных
влияний друг от друга, а также пользователей на ОС и обратно.
 
### Принцип открытой и наращиваемой ОС
Принцип открытости и наращиваемости ОС предусматривает возможность доступа
к ней для анализа пользователями, специалистами, обслуживающим персоналом, а также
изменения конфигурации ОС и ее мощности без осуществления процессов генерации.

> Всем ли принципам должна отвечать ОС?

Нет, это зависит от назначения ОС, а также от требований к ней предъявленных. Если приводить пример, то ОС для спутника будет отличаться от ОС для настольного ПК. 

> Какие принципы могут нарушаться для ОС различного назначения?

Ну опять же можно тот же пример со спутником привести. 

При проектировании операционных систем для космических спутников могут быть нарушены некоторые общепринятые принципы ОС в угоду специфическим требованиям, таким как надежность, долговечность и минимальное энергопотребление. Вот несколько примеров:

- Принцип функциональной избыточности: В ОС космического спутника может быть ограничено количество способов выполнения одних и тех же задач, чтобы минимизировать сложность и вероятность ошибок. Это может привести к снижению гибкости, но увеличивает надежность.

- Принцип модульности: Хотя модульность важна для удобства обслуживания и обновления, ОС спутника может быть спроектирована как более монолитная система с целью увеличения стабильности и надежности.

- Принцип генерируемости: ОС для космического спутника, как правило, специализирована и не предназначена для широкого круга пользователей. Поэтому способность к настройке под различные конфигурации аппаратных средств может быть ограничена.

- Принцип защиты: Хотя принцип защиты крайне важен, в условиях ограниченных ресурсов космического спутника могут быть сделаны упрощения в механизмах защиты, особенно если угроза внешнего вмешательства считается низкой.

- Принцип открытой и наращиваемой ОС: Операционная система космического спутника может быть закрытой и не предназначенной для модификации после запуска, чтобы обеспечить максимальную надежность и стабильность работы.

- Принцип по умолчанию: В ОС космического спутника может быть меньше настроек по умолчанию, доступных для изменения, поскольку система должна работать в очень строго определенных и контролируемых условиях.

- Таким образом, хотя многие общие принципы ОС сохраняются, некоторые из них могут быть адаптированы или даже нарушены в угоду уникальным требованиям и ограничениям, связанным с космическими условиями.


## Концептуальные основы ОС

1. Процесс - [определение дали на этом слайде](#жизненный-цикл-программы)
2. Ресурс - все те аппаратные и программные средства необходимые для выполнения процесса
3. Концепция виртуализации - Основная
идея заключается в том, что монитор виртуальных машин (Virtual Machine Monitor
(VMM)) создает иллюзию присутствия нескольких (виртуальных) машин на одном
и том же физическом оборудовании. VMM известен также как гипервизор. Его можно разделить на гипервизор первого типа, запускаемым
непосредственно на оборудовании, и гипервизор второго типа, который может вос-
пользоваться всеми полезными службами и абстракциями, предлагаемыми основной
операционной системой. Так или иначе, виртуализация позволяет одному компьютеру
стать базой для нескольких виртуальных машин, на каждой из которых потенциально
может быть запущена совершенно другая операционная система.
4. Взаимодействие с пользователем - для надежного управления ходом выполнения программ операционная система должна иметь по отношению к пользовательским процессам определённые привилегии — иначе некорректно работающее приложение сможет вмешаться в работу операционной системы. Например, взаимодействие с аппаратурой возможно только на самом высоком уровне привилегий, который не дается обычным программам. Чаще всего именно ядро является той частью операционной системы, которая работает в привилегированном режиме.
5. Дисциплина распределения ресурсов - 
6. Концепция прерывания - (hardware interrupt) событие, генерируемое внешним (по отношению к процессору) устройством. Посредством аппаратных прерываний аппаратура либо информирует центральный процессор о том, что произошло какое-либо событие, требующее немедленной реакции (например, пользователь нажал клавишу), либо сообщает о завершении асинхронной операции ввода-вывода (например, закончено чтение данных с диска в основную память). Важный тип аппаратных прерываний – прерывания таймера, которые генерируются периодически через фиксированный промежуток времени. Прерывания таймера используются операционной системой при планировании процессов. Каждый тип аппаратных прерываний имеет собственный номер, однозначно определяющий источник прерывания. Аппаратное прерывание – это асинхронное событие, то есть оно возникает вне зависимости от того, какой код исполняется процессором в данный момент. Обработка аппаратного прерывания не должна учитывать, какой процесс является текущим. 

> Может ли процесс рассматриваться как ресурс?

Я бы сказал что нет, так как наличие какого либо ресурса необходимо для выполнения процесса.

> Обязательно ли ОС должна взаимодействовать с пользователем

Нет, можно привести пример ОС, которой не требуется взаимодействие с пользователем. Например ОС для станка. По идее, ей нужна только поддержка и обслуживание, но это с натяжкой можно назвать взаимодействием с пользователем, тк она может годами функционировать самостоятельно. В общем, вопрос софистики, и все зависит от того, как мы определяем понятие пользователя.

## Мультипрограммирование

### Однопрограммные и мультипрограммные системы обработки данных

#### Однопрограммные системы обработки данных:

Однопрограммные системы, также известные как однозадачные системы, могут выполнять только одну задачу за раз. В таких системах, когда пользователь запускает программу, она получает полный контроль над ресурсами компьютера, включая процессор, память и устройства ввода/вывода. Другие задачи должны ожидать завершения текущей программы, прежде чем они смогут получить доступ к системным ресурсам.

Примеры:

Ранние персональные компьютеры, такие как те, что использовали операционные системы типа MS-DOS.
Простые встроенные системы, управляющие бытовой техникой или промышленным оборудованием.

#### Мультипрограммные системы обработки данных:

Мультипрограммные системы, известные также как многозадачные системы, позволяют одновременно выполнять несколько программ. Эти системы могут эффективно распределять ресурсы компьютера между различными задачами, что позволяет повысить производительность и удобство использования.

Примеры:

- Современные операционные системы, такие как Windows, macOS, Linux, которые позволяют пользователям одновременно работать с несколькими приложениями (например, браузером, текстовым редактором, почтовым клиентом).

- Серверные операционные системы, которые могут обрабатывать множество запросов одновременно, обслуживая различные клиенты.
Основные отличия:

Количество задач: Однопрограммные системы могут выполнять только одну задачу за раз, в то время как мультипрограммные могут выполнять множество задач одновременно.

Эффективность использования ресурсов: Мультипрограммные системы более эффективно используют ресурсы, поскольку они могут переключаться между задачами, минимизируя простои.

Удобство пользователя: Мультипрограммные системы обычно более удобны для пользователя, поскольку позволяют выполнять несколько операций одновременно.

Сложность: Мультипрограммные системы обычно сложнее в разработке и управлении из-за необходимости координировать доступ к ресурсам между множеством задач.

> Чем отличаются мультипрограммирование и многозадачность?

Из Таненбаума:

*Постоянное переключение между процессами, как мы уяснили в главе 1, называется мультипрограммированием, или многозадачным режимом работы.*

Исходя из этого отрывка вроде как кажется, что это одно и тоже. Ну тут как бы очев, что какая то разница все же есть. Не просто же так есть такой вопрос. Нашел в интернетах такое вот

*Мультипрограммность – это параллельное выполнение нескольких приложений, программист в этом случае не заботится о механизмах организации параллельной работы, эти функции выполняет ОС.
Мультизадачность предполагает, что программист заботится о параллельном выполнении и взаимодействии приложений.
В современной технической и научно-популярной литературе разницу не делают.*


# Лекция 2. Многопользовательский режим работы. Режим работы и ОС  реального времени. Универсальные операционные системы и ОС специального назначения. Классификация операционных систем. Модульная структура построения ОС.

## Многопользовательский режим работы ОС

### Сущность пользователь

В контексте операционных систем, "пользователь" обычно относится к лицу или процессу, который взаимодействует с системой для выполнения различных задач. Пользователи могут быть классифицированы по различным критериям, в зависимости от их роли, прав доступа и способа взаимодействия с системой. Вот несколько ключевых аспектов, относящихся к сущности пользователя в контексте операционных систем:

**Типы пользователей:**

- Конечные пользователи: Это физические лица, которые используют компьютер или устройство для выполнения повседневных задач, таких как работы в офисных приложениях, просмотр веб-страниц или игры.

- Администраторы системы: Эти пользователи имеют расширенные права и отвечают за управление и поддержку операционной системы. Они могут устанавливать и настраивать программное обеспечение, управлять пользователями и их правами, обеспечивать безопасность системы.

- Системные процессы: Это не физические лица, а программы или процессы, работающие в системе. Они также считаются пользователями, поскольку они используют ресурсы системы для выполнения своих задач.

**Учетные записи и аутентификация:**

Большинство операционных систем используют учетные записи пользователей для идентификации и аутентификации. У каждого пользователя обычно есть уникальное имя пользователя и пароль.
Права доступа и разрешения определяют, какие ресурсы и операции доступны каждому пользователю. Например, обычные пользователи могут иметь ограниченный доступ, в то время как администраторы имеют расширенные права.

**Интерфейс пользователя:**

Операционные системы предоставляют различные интерфейсы для взаимодействия с пользователями, включая графические пользовательские интерфейсы (GUI), командные строки и текстовые интерфейсы.

**Безопасность и управление доступом:**

Операционные системы обеспечивают безопасность и контроль доступа к ресурсам системы, используя механизмы управления доступом, такие как списки контроля доступа (ACL) и ролевые модели доступа.

**Пользовательские настройки и персонализация:**

Операционные системы позволяют пользователям настраивать и персонализировать свой опыт работы, включая настройки рабочего стола, темы, предпочтения приложений и многое другое.
В общем, пользователь в контексте операционных систем является центральным элементом, вокруг которого строится управление ресурсами, безопасность и пользовательский опыт.

> *Тут самое важно - это помнить, что пользователь может быть не только каким то физическим кожаным мешком с клавиатурой, но и некоторым системным процессом или программой. Например python, postgres, hadoop и так далее.*

! Как бы очев, что данные подходы(или как это правильно назвать) могут совмещать многопользовательский и многозадачный режимы, как например в много программ - много пользователей
 
### Одна программа - один пользователь

Этот подход предполагает, что каждая программа предназначена для использования одним пользователем. Это характерно для ранних персональных компьютеров и некоторых специализированных приложений.

**Примеры использования:** 

- Текстовый редактор на старом персональном компьютере; 
- специализированное ПО для обработки изображений.

**Преимущества:**

- Простота в использовании и управлении; 
- программное обеспечение оптимизировано под конкретные потребности пользователя.

**Недостатки:** 

- Ограниченная гибкость; 
- невозможность совместной работы нескольких пользователей.

### Одна программа - много пользователей

Здесь одна программа или служба предназначена для использования многими пользователями. Такие системы часто встречаются в сетевых и серверных приложениях.

Примеры использования: 

- Веб-серверы;
- базы данных; 
- корпоративные приложения.

Преимущества: 

- Эффективное использование ресурсов;
- упрощение администрирования; 
- возможность совместной работы.

Недостатки: 
- Сложности с безопасностью и конфиденциальностью данных;
- более высокие требования к управлению ресурсами.



### Много программ - один пользователь

Это подход многозадачной операционной системы, где один пользователь может запускать и использовать несколько программ одновременно.

Примеры использования: Современные операционные системы (Windows, macOS, Linux), где пользователи одновременно работают с браузером, офисными приложениями, медиа-плеерами и т.д.
Преимущества: Гибкость и многозадачность; повышение продуктивности пользователя.
Недостатки: Высокие требования к ресурсам системы; потенциальные проблемы с производительностью при одновременном выполнении многих задач.

### Много программ - много пользователей

Этот подход характерен для сетевых и многопользовательских систем, где множество пользователей могут одновременно работать с различными программами.

Примеры использования: Корпоративные сети, облачные сервисы, большие вычислительные кластеры.
Преимущества: Эффективное распределение ресурсов; масштабируемость; возможность совместной работы и обмена данными между пользователями.
Недостатки: Сложности в управлении и обеспечении безопасности; высокие требования к аппаратным ресурсам и надежности системы.


Каждый из этих подходов находит свое применение в зависимости от конкретных целей и условий, и выбор подхода определяется требованиями к функциональности, производительности, безопасности и другим факторам.

> Чем отличается многопользовательский режим от мультипрограммного?



## Универсальные операционные системы и ОС специального назначения

Универсальные ОС - очевидно

![Alt Text](https://media.tenor.com/KUh2w288l80AAAAC/dugin-based.gif)

